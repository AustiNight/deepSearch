API Endpoints

What is an API Endpoint?
The “endpoint” of a SODA API is simply a unique URL that represents an object or collection of objects. Every Socrata dataset, and even every individual data record, has its own endpoint. The endpoint is what you’ll point your HTTP client at to interact with data resources.

All resources are accessed through a common endpoint of /api/v3/views/IDENTIFIER/query.json along with their dataset identifier. This paradigm holds true for every dataset in every SODA API. All datasets have a unique identifier - eight alphanumeric characters split into two four-character phrases by a dash. For example, ydr8-5enu is the identifier for the Building Permits. This identifier can then be inserted into the /api/v3/views/IDENTIFIER/query endpoint to construct the API endpoint.

The TryIt macro has been disabled until future notice while we upgrade this site to SODA3.
Once you’ve got your API endpoint, you can make requests with SoQL to filter and manipulate your dataset.

Locating the API endpoint for a dataset
You can also find API endpoints, and links to detailed developer documentation for each dataset, in a number of different places, depending on where you are:

If you’re viewing a dataset listing within the Open Data Network, there will be a prominent “API” button that will take you directly to the API documentation for that dataset.  See this

If you’re viewing a dataset directly, there will be an “API Documentation” button under “Export” and then “SODA API”.  See this

Endpoint Versioning
SODA and SoQL are very flexible and allow us to add functionality over time without needing to completely deprecate and replace our APIs. We can do so in several different ways:

By introducing new SoQL functions that provide new functionality. We could, for example, add a new function that allows you to filter or aggregate a dataset in a new way.
By adding new datatypes to represent new data, like a new datatype for a new class of geospatial data.
This allows us to introduce additional capabilities while still allowing you to issue the same kinds of queries in a backwards-compatible manner. We can extend SODA APIs without needing all developers to migrate their code to a new version.

However, some functionalities are not available on all of our API endpoints, which is why we differentiate between versions of a dataset’s API. Functions made available on a newer version might not be available on an API endpoint of an older version. In the sidebar of our automatic API documentation, we list the version that that endpoint complies with, as well as other useful information.  See this

Throughout the documentation on this developer portal you’ll notice version toggles and info boxes that will help you understand the difference between SODA endpoint versions.


Version 3.0 (Latest)
The next iteration of SODA will be released in 2025 and changes the endpoint from /resource/IDENTIFIER.json to /api/v3/IDENTIFIER/query.json. Notable changes:

Query requests must be either authenticated by a user or marked with a valid application token.
We have separated the endpoint into two:
/query for querying (e.g., https://data.cityofchicago.org/api/v3/views/ydr8-5enu/query.json) Query primarily supports machine-readability and has more options for customizing the request.
/export for exports (e.g., https://data.cityofchicago.org/api/v3/views/ydr8-5enu/export.csv) Export supports more formats and focuses on generating something readable by humans.
We strongly prefer that use the HTTP POST method when requesting queries, as this allows for longer queries and clearer options.

Version 2.1
The first SODA 2.1 APIs (previously referred to as our “high-performance Socrata Open Data APIs”) were released in April of 2015, and in November of 2015 they received the “2.1” version designation for clarity. SODA 2.1 introduces a number of new datatypes as well as numerous new SoQL functions:

Tons of new advanced SoQL functions to introduce powerful filtering and analysis into your queries
New geospatial datatypes like Point , Line , and Polygon replace the Location datatype
Support for the standardized GeoJSON output format, for direct use within geospatial tools like Leaflet
Closer compliance with SQL semantics, such as Text comparisons becoming case-sensitive
Currently only the JSON, CSV, and GeoJSON output formats are supported
New functionality will be added to this version over time.

For more information:

SoQL functions that work with version 2.1
Datatypes that are available in version 2.1

Version 2.0
SODA 2.0 was originally released in 2011. Although 2.1 is backwards-compatible with 2.0, there are a number of differences between the two APIs:

2.0 supports fewer SoQL functions than 2.1.
The only geospatial datatype supported is the Location datatype
Text comparisons are case-insensitive
For more information:

SoQL functions that work with version 2.0
Datatypes that are available in version 2.0
Versioning HTTP headers
The simplest way to tell the difference between a 2.0 API and a 2.1 API is via the X-SODA2-Legacy-Types header, which will be true if you’re accessing a legacy 2.0 API.

When we will increment endpoint versions
From time to time, we’ll introduce new SoQL functions and datatypes to the latest version of the SODA API. Those changes will be non-breaking, and old queries and applications will continue to function unchanged. The SODA API is designed to make it easy to introduce new functionality over time without making breaking changes.


Row Identifiers

What is a Row Identifier?
Socrata datasets are essentially a collection of rows. Each row can be uniquely designated by its “row identifier”, much like a driver’s license number or social security number identifies an individual. For those familiar with database concepts, they essentially act the same way as primary keys.

Internal Identifiers vs Publisher-Specified Identifiers
Row identifiers come in two flavors:

Internal identifiers are auto-generated by the Socrata platform every time a new row is created.
Publisher-specified identifiers are configured by the dataset owner and use a field of unique values within the dataset as the row identifier.
Depending on what dataset you're accessing, internal row identifiers may be simple integers, or alphanumeric strings. There's no difference between the two in how you use them.

To learn more about how to access internal row identifiers, read the System Fields documentation.

Establishing a Publisher-Specified Identifier
Setting a row identifier requires that you are either the owner of a dataset, or that you've been granted a role of Publisher or Administrator on a Socrata customer site. Basically, if you can't modify the dataset, you can't set a row identifier.

A publisher-specified row identifier can be established for any Socrata dataset. A common column to use as a row identifier is an ‘ID’ column with some kind of number or code that uniquely identifies that row of data. For example, the ‘Inspection ID’ column of Chicago’s Food Inspections dataset is a Publisher-specified row identifier.

How to Set a Row Identifier
See this helpful guide on how to set a row identifier in Socrata.


RESTful Verbs

The Socrata API follows the REST (REpresentational State Transfer) design pattern. This means that the CRUD (Create, Read, Update, and Delete) operations are specified by using HTTP methods. These are referred to as RESTful verbs.

GET
Use the HTTP GET method to obtain data. As described in the Endpoints section, GET can be used to retrieve column data from multiple rows or from one single row. The Queries section describes how to do sophisticated queries, all with the GET method.

For SODA3, you must authenticate or use an application token in order to query for or export data. You may preferentially use POST, which is useful if your SoQL query is very long.

POST
Use the HTTP POST method to add new rows in a dataset. See the SODA Producer API section for more details on how to add data.

Note that you will need to authenticate in order to make changes. See the Authentication section for more information on how to do this.

PUT
Use the HTTP PUT method to modify data. Like POST, you will need authentication. Again, see the SODA Producer API and Authentication sections for more information.

DELETE
Use the HTTP DELETE method to remove data. Like POST and PUT, you will need authentication. Again, see the SODA Producer API and Authentication sections for more information.


Application Tokens

The Socrata Open Data API uses application tokens for two purposes:

Using an application token allows us to throttle by application, rather than via IP address, which gives you a higher throttling limit
Authentication using OAuth
Throttling limits
Without an application token, we can only track usage and perform throttling based on a few simple criteria, mainly source IP address. As such, requests that aren’t using an application token come from a shared pool via IP address. IP addresses that make too many requests during a given period may be subject to throttling.

When requests are made using an application token, we can actually attribute each request to a particular application and developer, granting each their own pool of API requests. Currently we do not throttle API requests that are using an application token, unless those requests are determined to be abusive or malicious.

We reserve the right to change these throttling limits with notice, and we will post an update to announce any such change.

If you are throttled for any reason, you will receive a status code 429 response.

Don’t be a jerk!
Dont do that!

Yes, I know it says you get unlimited requests. But keep in mind that you’re using a shared platform, and you should still be deliberate in how you design your application to use our API. Applications that are determined to be abusive or malicious, or that otherwise monopolize the use of our API may be throttled.

If we detect that your application is nearing the point where we may have to throttle it, we will likely pro-actively reach out to you to discuss how you can optimize your usage. If you have any questions, feel free to contact us and we’d be glad to help!


Obtaining an Application Token
You can obtain an application token by registering for one in your Socrata profile.

Using your Application Token
While it is possible to perform simple unauthenticated queries against the Socrata Open Data API without making use of an application token, you’ll receive much higher throttling limits if you include an application token in your requests. If you elect not to use an application token, you’ll be subjected to a much lower throttling limit for all requests originating from your IP address.

Here’s how you include the application token in the request:

SODA Version	Method
3.0, 2.x	Use the X-App-Token HTTP header.
2.1, 2.0	Use the $$app_token parameter in your request.
1.0	Use the app_token parameter in your request.
Using the header is the preferred method.

Note: Application tokens are not necessarily used for authentication, but you should still preserve the security of your application token by always using HTTPS requests. If your application token is duplicated by another developer, their requests will count against your quota.
The following is an example of using the X-App-Token HTTP header to pass an application token:

POST /api/v3/views/kzjm-xkqj/query.json HTTP/1.1
Host: data.seattle.gov
Accept: application/json
X-App-Token: [REDACTED]
The same application token could also be passed as a URL parameter:

The TryIt macro has been disabled until future notice while we upgrade this site to SODA3.
Using the Application Token as part of the OAuth 2.0 authentication process
Application tokens can also be used for authentication using OAuth 2.0. For more information, see the authentication section.


Authentication

There are two methods available for authentication: HTTP Basic and OAuth 2.0. For non-interactive applications, we only support HTTP Basic Authentication. We encourage all our developers of interactive applications to use the OAuth 2.0 workflow to authenticate their users.

HTTP Basic Authentication is required when you are authenticating from a script that runs without interaction with the user, like your ETL tool, an update script, or any other data management automation.

OAuth 2.0 is the preferred option for cases where you are building a web or mobile application that needs to perform actions on behalf of the user, like accessing data, and the interaction model allows you to present the user with a form to obtain their permission for the app to do so.

Authenticating using HTTP Basic Authentication
Requests can be authenticated using HTTP Basic Authentication. You can use your HTTP library’s Basic Auth feature to pass your credentials. All HTTP-basic-authenticated requests must be performed over a secure (https) connection. Authenticated requests made over an insecure connection will be denied.

Users may use their username and password or an API key and secret pair to authenticate using Basic Authentication. Documentation on how to create and manage API keys can be found here.

We recommend using API keys! They provide the following benefits:

Access Socrata APIs without the risk of embedding your username and password in scripts or code
Users on domains that require SSO (and thus without passwords) can access Socrata APIs
Create individual keys for different apps or jobs so that if any one needs to be revoked or rotated, other apps are unaffected
Change your account password without disrupting apps or rotate API keys without disrupting logins
Here is a sample HTTP session that uses HTTP Basic Authentication:

POST /api/v3/views/4tka-6guv/query.json HTTP/1.1
Host: soda.demo.socrata.com
Accept: */*
Authorization: Basic [REDACTED]
Content-Length: 253
Content-Type: application/json
X-App-Token: [REDACTED]

[ {
  ...
} ]
Note that the Authorization header in this request will usually be generated via your HTTP library’s Basic Auth feature (as opposed to manually constructing the Base64 encoding of your credentials yourself). For example, if you’re using Python’s requests module, it supports Basic Authentication out of the box. Similarly, an API tool like Postman also handles Basic Authentication.

OAuth 2.0
Note: When developing applications that make use of OAuth, you must provide a web-accessible callback URL when registering your application token. This can make it difficult to develop on a machine that isn't directly exposed to the Internet. One great option is to use a tool like ngrok to create a secure tunnel to expose your web application in a secure manner.
Workflow
We support a subset of OAuth 2.0 — the server-based flow with a callback URL — which we believe is more secure than the other flows in the specification. This OAuth flow is used by several other popular API services on the web. We have made the authentication flow similar to Google AuthSub.

To authenticate with OAuth 2.0, you will first need to register your application, which will create an app token and a secret token. When registering your application, you must preregister your server by filling out the Callback Prefix field), so that we can be sure that access through your application is secure even if both your tokens are stolen. The Callback Prefix is the beginning of the URL that you will use as your redirect URL. Generally, you’ll want to provide as much of your callback URL as you can. For example, if your authentication callback is https://my-website.com/socrata-app/auth/callback, you might want to specify https://my-website.com/socrata-app as your callback URL.

Once you have an application and a secret token, you’ll be able to authenticate with the SODA OAuth 2.0 endpoint. You’ll first need to redirect the user to the Socrata-powered site you wish to access so that they may log in and approve your application. For example:

https://soda.demo.socrata.com/oauth/authorize?client_id=YOUR_AUTH_TOKEN&response_type=code &redirect_uri=YOUR_REDIRECT_URI
Note that the redirect_uri here must be an absolute, secure (https:) URI which starts with the Callback Prefix you specified when you registered your application. If any of these cases fail, the user will be shown an error indicating as much.

Should the user authorize your application, they will be redirected back to the your redirect_uri. For example, if I provide https://my-website.com/socrata-app/auth/callback as my redirect_uri, the user will be redirected to this URL:

https://my-website.com/socrata-app/auth/callback?code=CODE
where CODE is an authorization code that you will use later.

If your redirect_uri contains a querystring, it will be preserved, and the code parameter will be added onto the end of it. Likewise, if you provide the optional state parameter in the original redirect to /authenticate, it will be preserved and sent back to you.

Now that the user has authorized your application, the next step is to retrieve an access_token so that you can perform operations on their behalf. You can do this by making the following POST request from your server:

https://soda.demo.socrata.com/oauth/access_token

{
    "client_id": YOUR_AUTH_TOKEN,
    "client_secret": YOUR_SECRET_TOKEN,
    "grant_type": "authorization_code",
    "redirect_uri": YOUR_REDIRECT_URI,
    "code": CODE
}
where YOUR_AUTH_TOKEN and YOUR_SECRET_TOKEN are the tokens you received when registering your app, YOUR_REDIRECT_URI is the same value as what you used previously, and CODE is the value of the code query parameter of the URL that the user was redirected to.

You’ll receive the following response:

{ access_token: ACCESS_TOKEN }
Use this access_token in your requests when you have to do work on behalf of the now-authenticated user, as described below in the Using an OAuth 2.0 Access Token section.

We have a sample app available on GitHub that illustrates how to do all of the above with the Ruby OAuth2 gem.

Using an OAuth 2.0 Access Token
Once you have obtained an access_token, you should include it on requests which need to happen on behalf of the user. The token must be included in the Authorization HTTP Header field as follows:

Authorization: OAuth YOUR_ACCESS_TOKEN
Note: All authenticated requests must be performed over a secure connection (https). Any attempt to use an access_token over a non-secure connection will result in immediate revocation of the token.

Who am I?
One quirk of authenticating via OAuth 2.0 is that the entire process happens without the 3rd party application (that’s you!) having any knowledge of who, exactly, the user is that just authorized the application. To remedy this, we have set up an endpoint that simply returns the information of the current user. To return the data in JSON:

https://soda.demo.socrata.com/api/users/current.json
To return the data in XML:

https://soda.demo.socrata.com/users/current.xml


Response Codes & Headers

Response Codes
The Socrata Open Data API responds with standard HTTP Status Codes for both successful requests and for errors. The table below lists the response codes you should expect to see.

Code	Error	Description
200	OK	Your request was successful
202	Request Processing	You can retry your request, and when it’s complete, you’ll get a 200 instead
400	Bad Request	Probably your request was malformed. See the error message in the body for details
401	Unauthorized	You attempted to authenticate but something went wrong. Make sure you follow the instructions to authenticate properly
403	Forbidden	You’re not authorized to access this resource. Make sure you authenticate to access private datasets
404	Not Found	The resource requested doesn’t exist
429	Too Many Requests	Your client is currently being rate limited. Make sure you’re using an app token
500	Server Error	Our bad! Something has gone wrong with Socrata’s platform. Please let us know if you encounter a 500 error
Headers
For SODA 2.1 API calls, we include a few response headers that may be useful:

Header	Example	Description
X-Socrata-RequestId	aqe1bgaxzvhitfgrsvy6semhi	A unique ID for this particular request. Very useful to include when asking for help, as it allows us to track your error down in our system
Access-Control-Allow-Origin	*	Allows browsers to make cross-origin requests for data
X-SODA2-Fields	["business","category", ...] (truncated)	An array of the field names that may be included in this response
X-SODA2-Types	["text","text",...] (truncated)	An array of the data types for fields included in this response
Last-Modified	Tue, 24 Feb 2015 18:51:22 GMT	When the dataset backing this request was updated; may be used for caching
ETag	"YWxwaGEuNTQzNV8...-gzip" (truncated)	An HTTP ETag which may be used for cache validation
There may be other headers included in responses, but they should not be relied upon and may change without notice.

HTTP Headers are limited by practical constraints to a maximum size of 4K. In order to keep our request header sizes below that limit, the X-SODA2-Fields and X-SODA2-Types headers may be omitted for datasets with a very large number of columns.

Error Messages
For any variety of error, we return a standard error message format that looks like the following:

 {
  "code" : "soql.analyzer.typechecker.type-mismatch",
  "error" : true,
  "message" : "Type mismatch: expected text, but found number",
  "status" : 400,
  "data" : {
    "found" : "number",
    "expected" : [ "text" ]
  },
  "source" : {
    "position" : {
      "column" : 30,
      "row" : 1,
      "text" : "select * where string_column > 42"
    },
    "type" : "anonymous"
  }
}
In particular:

code: An enumeration for the particular class of error you have encountered
error: A boolean flag you can check in your code if your library masks the HTTP error code. Ex: if(response.error) { // handle error }
message: A human-readable error message that will help you debug what caused the error
data: Machine-readable data about the error, most importantly the query generated by our SoQL parser based on your inputs


System Fields

In addition to the fields provided by the dataset owner, Socrata also provides a number of useful system fields you can make use of. They’re very useful for detecting when datasets have changed.

Operator	Description
:id	The internal Socrata identifier for this record.
:created_at	A Fixed Timestamp representing when this record was created.
:updated_at	A Fixed Timestamp representing when this record was last updated.
System fields are not included by default, and the method that you use to request the inclusion of the hidden system fields depends on what version of the SODA API specification the API you are accessing complies with. To learn more about API versioning, see the API Endpoint documentation.

Version 2.1
With version 2.1 APIs, accessing the system fields is as simple as including them in your $select parameter, either explicitly or via a wildcard. You can either $select=:id, :updated_at, name, address, or you could be even more broad and simply select :*, * to retrieve both all of the hidden internal fields and the fields from the dataset itself. For example:

The TryIt macro has been disabled until future notice while we upgrade this site to SODA3.
Since :created_at and :updated_at are Fixed Timestamp, you can query them to get recent updates to a dataset using the $where query parameter, like this example:

The TryIt macro has been disabled until future notice while we upgrade this site to SODA3.
A note on how datasets are updated
Data providers use many different methods to update datasets. In some cases, they use tools like DataSync or the SODA Producer API to update datasets, and we can tell which records within the dataset have actually been modified, and only update them accordingly. When data providers perform a full replace of the dataset using the SODA Producer Replace API, all of its records will be updated within a short period of time, in which case a query based on :updated_at will show that all of the records have changed.

Version 2.0
Getting the SODA API to return system fields is as simple as adding the parameter $$exclude_system_fields=false to your request. The double dollar sign ($$) is significant - it denotes a Socrata-specific parameter that is not part of the SODA standard.

The TryIt macro has been disabled until future notice while we upgrade this site to SODA3.



CORS & JSONP

For security reasons, web browsers prevent what are called “cross-origin” or “cross-site” requests from one domain to another. JavaScript XMLHTTPRequests (commonly called “AJAX” requests) inherit all of the authentication context of the currently logged in user, so a malicious web page could attempt to make malicious requests that cross domain contexts and cause trouble. Historically, that has made it difficult for web developers to build web applications making use of third-party APIs.

Fortunately, techniques have since been developed that allow developers to securely access APIs cross-domain. The two most popular ones, and the techniques that Socrata supports, are CORS and JSONP.

A note on CORS, JSONP, and dataset permissions
In order to prevent the aforementioned malicious cross-site attacks, Socrata automatically drops all authentication and authorization on requests that come in via CORS and JSONP. As a result, these techniques can only be used to access public datasets in a read-only fashion.

Cross-Origin Resource Sharing (CORS)
CORS is a proposed standard for allowing your web browser and a web server to negotiate and allow requests to be made across domain contexts. CORS is currently supported in modern Chrome, Firefox, Safari, and Internet Explorer (10+) web browsers. The standard itself is working its way through the W3C on its way to becoming official.

You don’t need to do anything special to use CORS with JavaScript in a modern browser. Your web browser and our servers will automatically negotiate the cross-origin request. For example, to make a CORS request with jQuery, you’d make your request just like you were performing it within the context of your own domain.

$.ajax({
  url: "https://data.chattlibrary.org/api/v3/views/e968-fnk9/query.json",
  method: "POST",
  dataType: "json",
  data: JSON.stringify({
    "query": "SELECT * WHERE status = 'CLOSED'",
    "page": {
      "pageNumber": 1,
      "pageSize": 1000
    },
    "includeSynthetic": false
  }),
  headers: {
    'Content-Type': 'application/json',
    'X-App-Token': app_token
  },
  success: function( data, status, jqxhr ){
    console.log( "Request received:", data );
  },
  error: function( jqxhr, status, error ){
    console.log( "Something went wrong!" );
  }
});
“JavaScript with Padding” (JSONP)
If you’re developing for older browsers, or you just feel like being nostalgic, you can also make use of our support for JSONP. Also called “JSON with Padding”, it is a technique for fooling a web browser into performing cross-origin requests using a special <script> tag that uses the src attribute to make a special API request. Instead of responding with just a JSON object, the server responds with JavaScript code that calls a client-declared callback function, passing the data as that function’s first parameter. With the Socrata API, the name of that callback function is declared using the $jsonp parameter.

Sounds hacky, huh? Fortunately, tools like jQuery make it easy to use JSONP:

$.ajax({
  url: "https://data.chattlibrary.org/resource/e968-fnk9.json",
  jsonp: "$jsonp",
  dataType: "jsonp"
}).done(function(data) {
  console.log("Request received: " + data);
});
But, as we mentioned, you should only need to use JSONP as a fallback in cases where you’re working with a browser that doesn’t support CORS.


Queries using SODA3

The Socrata APIs provide rich query functionality through a query language we call the “Socrata Query Language” or “SoQL”. As its name might suggest, it borrows heavily from Structured Query Language (SQL), used by many relational database systems. Its paradigms should be familiar to most developers who have previously worked with SQL, and are easy to learn for those who are new to it.

Requests must be either authenticated by a user or marked with a valid application token. Developers should now use the HTTP POST method when requesting queries, as this allows for longer queries and clearer options.

The endpoints are split into two:

/query for querying (e.g., https://data.cityofchicago.org/api/v3/views/ydr8-5enu/query.json) Query has more options for customizing the request so that you can fine-tune what data you want back.
/export for exports (e.g., https://data.cityofchicago.org/api/v3/views/ydr8-5enu/export.csv) Export focuses on providing the entire dataset to be consumed by humans or Microsoft Excel or similar programs.
You can click on each option to see more information about them:

Request Option	/query	/export	Description
query	available	available	The SoQL query to run
page	available	not available	{ pageNumber: 1, pageSize: 1000 } to indicate which page (1-indexed) and how many rows per page
parameters	available	available	Some views require parameters to be provided by the user. Details to be provided at a later date
timeout	default: 600	default: 600	The number of seconds before timing out the request. Default: 600 (10 minutes)
includeSystem	default: true	not available	Whether or not to include system columns
includeSynthetic	default: true	not available	Whether or not to include not-explicitly-requested columns, such as system fields
orderingSpecifier	default: total	default: total	Can be set to discard if you do not care about order and just want the data. Can improve performance significantly
serializationOptions	not available	available	Different formats have specific customization options.
Example
You might use the popular program cURL to make the request with the appropriate payload, or use an appropriate HTTP client library in your preferred programming language.

Query for the first 100 rows of a dataset:

curl --header 'X-App-Token: your-application-token' \
     --json '{
        "query": "SELECT *",
        "page": {
            "pageNumber": 1,
            "pageSize": 100
        },
        "includeSynthetic": false
     }' \
     https://soda.demo.socrata.com/api/v3/views/4tka-6guv/query.json
Export the dataset as CSV with a byte-order mark and a separator character of TAB:

curl --header 'X-App-Token: your-application-token' \
     --json '{
       "serializationOptions": {
         "separator": "\t",
         "bom": true
       }
     }' \
     https://soda.demo.socrata.com/api/v3/views/4tka-6guv/export.csv


     SoQL Function and Keyword Listing

The following are all the functions and keywords available in SoQL. Some only work on the the latest version of our API endpoints, while some work on legacy versions as well. You can filter them by endpoint version and datatype using the filters below.

For a list of valid operators, see the Datatypes documentation.

 
Keyword Name	Description	Availability 
distinct	Returns distinct set of records	2.1 and 3.0
Function Name	Description	Availability 
avg(...)	Returns the average of a given set of numbers	2.0, 2.1, and 3.0
between ... and ...	Returns TRUE for values in a given range	2.1 and 3.0
case(...)	Returns different values based on the evaluation of boolean comparisons	2.1 and 3.0
convex_hull(...)	Returns the minimum convex geometry that encloses all of another geometry	2.1 and 3.0
count(...)	Returns a count of a given set of records	2.0, 2.1, and 3.0
date_extract_d(...)	Extracts the day from the date as an integer.	2.1 and 3.0
date_extract_dow(...)	Extracts the day of the week as an integer between 0 and 6 (inclusive).	2.1 and 3.0
date_extract_hh(...)	Extracts the hour of the day as an integer between 0 and 23 (inclusive).	2.1 and 3.0
date_extract_m(...)	Extracts the month as an integer.	2.1 and 3.0
date_extract_mm(...)	Extracts the minute from the time as an integer.	2.1 and 3.0
date_extract_ss(...)	Extracts the second from the time as an integer.	2.1 and 3.0
date_extract_woy(...)	Extracts the week of the year as an integer between 0 and 51 (inclusive).	2.1 and 3.0
date_extract_y(...)	Extracts the year as an integer.	2.1 and 3.0
date_trunc_y(...)	Truncates a calendar date at the year threshold	2.0, 2.1, and 3.0
date_trunc_ym(...)	Truncates a calendar date at the year/month threshold	2.0, 2.1, and 3.0
date_trunc_ymd(...)	Truncates a calendar date at the year/month/date threshold	2.0, 2.1, and 3.0
distance_in_meters(...)	Returns the distance between two Points in meters	2.1 and 3.0
extent(...)	Returns a bounding box that encloses a set of geometries	2.1 and 3.0
greatest(...)	Returns the largest value among its arguments, ignoring NULLs.	2.1 and 3.0
in(...)	Matches values in a given set of options	2.1 and 3.0
intersects(...)	Allows you to compare two geospatial types to see if they intersect or overlap each other	2.1 and 3.0
least(...)	Returns the smallest value among its arguments, ignoring NULLs.	2.1 and 3.0
like '...'	Allows for substring searches in text strings	2.1 and 3.0
ln(...)	Returns the natural log of a number	2.1 and 3.0
lower(...)	Returns the lowercase equivalent of a string of text	2.1 and 3.0
max(...)	Returns the maximum of a given set of numbers	2.1 and 3.0
min(...)	Returns the minimum of a given set of numbers	2.1 and 3.0
not between ... and ...	Returns TRUE for values not in a given range	2.1 and 3.0
not in(...)	Matches values not in a given set of options	2.1 and 3.0
not like '...'	Allows for matching text fields that do not contain a substring	2.1 and 3.0
num_points(...)	Returns the number of vertices in a geospatial data record	2.1 and 3.0
regr_intercept(...)	Returns the y-intercept of the linear least squares fit	2.1 and 3.0
regr_r2(...)	Returns the square of the correlation coefficient (r²)	2.1 and 3.0
regr_slope(...)	Returns the slope of the linear least squares fit	2.1 and 3.0
simplify(...)	Reduces the number of vertices in a line or polygon	2.1 and 3.0
simplify_preserve_topology(...)	Reduces the number of vertices in a line or polygon, preserving topology	2.1 and 3.0
starts_with(...)	Matches on text strings that start with a given substring	2.1 and 3.0
stddev_pop(...)	Returns the population standard deviation of a given set of numbers	2.1 and 3.0
stddev_samp(...)	Returns a sampled standard deviation of a given set of numbers	2.1 and 3.0
sum(...)	Returns the sum of a given set of numbers	2.1 and 3.0
unaccent(...)	Removes accents (diacritical marks) from a string.	2.1 and 3.0
upper(...)	Returns the uppercase equivalent of a string of text	2.1 and 3.0
within_box(...)	Returns the rows that have geodata within the specified box, defined by latitude, longitude corners	2.0, 2.1, and 3.0
within_circle(...)	Returns the rows that have locations within a specified circle, measured in meters	2.0, 2.1, and 3.0
within_polygon(...)	Returns the rows that have locations within the specified box, defined by latitude, longitude corners	2.1 and 3.0


Data Transform Listing

These are the transformation functions available in the Dataset Management API. These functions can be used to transform and validate your data before you publish your dataset for consumption.

These functions can be used in the “Data Transforms” editor of the the Dataset Management Experience interface. Check out some of the examples on our Support Portal here!

See the Dataset Management API docs for more info on how to use the transform functions as an API user.

Function Name	Description
+	Keep a number’s sign
and	Logical and of two boolean values
||	concatenate two strings
/	Divide a number by another
=	Return true if the left side equals the right
==	Return true if the left side equals the right
^	No documentation is available.
>	Return true if the value on the left is greater than the value on the right
>=	Return true if the value on the left is greater than or equal to the value on the right
<	Return true if the value on the left is less than the value on the right
<=	Return true if the value on the left is less than or equal to the value on the right
%	Find the remainder(modulus) of one number divided by another
*	Multiply two numbers together
not	Invert a boolean
<>	Return true if the left side does not equal the right
!=	Return true if the left side does not equal the right
or	Logical or of two boolean values
-	Subtract a number from another
abs	Produce the absolute value of a number
between	Return true if the left is within the range of the right values
case	Evaluate a series of true/false expressions (predicates) and return the next consequent.
centroid	returns the geometric centroid of a polygon or multipolygon. Please refer to
coalesce	Take the leftmost non-null value.
contains	tell whether or not a string contains another string
county_boundary	Returns the boundary of the US county as a multipolygon. The state name is not case sensitive.
date_extract_d	Extract the day from the date as an integer
date_extract_dow	Extracts the day of the week as an integer between 0 and 6 where
date_extract_hh	Extract the hour the date as an integer
date_extract_m	Extract the month as an integer
date_extract_mm	Extract the minute from the date as an integer
date_extract_ss	Extract the second from the date as an integer
date_extract_woy	Extracts the week of the year as an integer between 0 and 51
date_extract_y	Extract the year as an integer
date_trunc_y	Truncates a calendar date at the year threshold
date_trunc_ym	Truncates a calendar date at the year/month threshold
date_trunc_ymd	Truncates a calendar date at the year/month/day threshold
datetime_add_d	Adds or subtracts the specified number of days to the timestamp
datetime_add_hh	Adds or subtracts the specified number of hours to the timestamp
datetime_add_mm	Adds or subtracts the specified number of minutes to the timestamp
datetime_add_ss	Adds or subtracts the specified number of seconds to the timestamp
datetime_diff	Calculates the difference between two dates in seconds, minutes, hours, days, business days, weeks, calendar weeks, months, or years.
domain_categories	Returns the categories currently configured on the domain. Useful primarily
domain_licenses	Returns the licenses currently configured on the domain. Useful primarily
email_parse	Parse an email. This is best effort as most things are actually
ensure_within	ensure_within is a function which takes a point and a multipolygon
error	Make an error. This is useful in conjunction with a case function,
floating_timestamp_day	Extract the day from a calendar date
floating_timestamp_day_of_week	Extract the day of the week as an integer between 0 and 6 where Sunday is 0.
floating_timestamp_hour	Extract the hour from a calendar date
floating_timestamp_minute	Extract the minute from a calendar date
floating_timestamp_month	Extract the month from a calendar date
floating_timestamp_second	Extract the second from a calendar date
floating_timestamp_week_of_year	Extract the week from a calendar date as an integer between 0 and 51.
floating_timestamp_year	Extract the year from a calendar date
forgive	forgive can take an optional default argument
from_polyline	convert a linestring encode in Google’s polyline format with the given precision to a Line
geocode	geocode is a function which takes human readable addresses
geocode_esri	geocode_esri is a function which takes human readable addresses
grapheme_length	the length of a piece of text in unicode grapheme clusters.
greatest	return the largest value among its arguments (ignoring null)
hash	Construct a hash value from a string value using either the md5 or sha256 algorithm.
haversine_distance	Return the distance of the line using haversine formula
http_get	Make an HTTP Get request to a URL. The response is returned. If the server
in	Whether or not a value is in a set of other values
is_empty	Returns whether or not the input is empty. Empty means null values,
is_not_null	Whether or not a value is not null
is_null	Whether or not a value is null
is_within	is_within is a function which takes a point and a multipolygon
json_array_contains	Test if a json array contains an item. If the JSON passed to this function is not an array,
json_pluck	Pluck a value out of a JSON string. The returned value will be a SoQL Json value.
json_pluck_boolean	Pluck a boolean value out of a JSON string. The returned value must be a boolean, otherwise
json_pluck_number	Pluck a number value out of a JSON string. The returned value must be a number, otherwise
json_pluck_text	Pluck a text value out of a JSON string. The returned value may be a primitive like a
least	return the smallest value among its arguments (ignoring null)
left_pad	Pad text with the minimum number of copies of pad to reach desired_length.
length	the length of a piece of text in unicode code points. This is usually, but not
like	If a string is like another string.
location_address	Extract the address from a location
location_city	Extract the city from a location
location_point	Extract the point from a location
location_state	Extract the state from a location
location_to_point	Turn a location value into a point
location_zip	Extract the zip from a location
lower	lowercase a string
make_location	This function has been deprecated. Please use the make_point function instead.
make_point	function to make a point out of a Y (latitude) and X (longitude) coordinate.
make_url	No documentation is available.
not_between	Return true if the left is not within the range of the right values
not_in	Whether or not a value is absent from a set of other values
not_like	If a string is not like another string.
parse_address	Extract a street address from a full US address.
parse_city	Extract a city from a full US address.
parse_point	Extract the point from a full US address with point.
parse_state	Extract a state from a full US address.
parse_zip	Extract a ZIP code from a full US address.
point_latitude	Extract the latitude from a point
point_longitude	Extract the longitude from a point
polylabel	Returns a point that must exist within the polygon borders. It uses the recursive grid-based algorithm described here: https://github.com/mapbox/polylabel#how-the-algorithm-works. When given a multipolygon, the point it returns is within the largest (by area) sub-polygon.
random_number_between	Returns a random float using a uniform distribution between the lower and upper values supplied: random_number_between(lower, upper)
random_number_normal	Returns a random float using a normal distribution with the mean and variance supplied: random_number_normal(mean, variance)
regex_capture	function to capture a piece of text based on a regular expression
regex_named_capture	capture a piece of text based on a regular expression
regex_replace	function to replace a piece of text based on a regular expression
region_code	Turn a point into the ID of a region, based on which region the point falls within. For example, if this dataset can produce
region_code_label	Identical to region_code, but returns a text value.
repair_geometry	Attempt to repair the geometry.
replace	replace text with another piece of text
replace_first	replace the first occurrence of a piece of text with another piece of text
reproject	reproject a geometry from one projection to another.
reproject_to_wgs84	function to reproject a geometry to WGS84. This will allow the geometry
right_pad	Pad text with the minimum number of copies of pad to reach desired_length.
round	Round a number to a given precision. Trailing zeros are removed by default. Negative precisions round numbers to the left of the decimal.
set_projection	function to explicitly set the projection value on geometries which do not have projection
simplify	Returns a simplified version of the Line, Polygon, MultiLine, or MultiPolygon using
simplify_preserve_topology	Returns a simplified version of the Line, Polygon, MultiLine, or MultiPolygon using
slice	Get a substring of a specified length of a text from a start index
source_created_at	Get the fixed timestamp that this data source was created (ie: started uploading or importing).
split_select	function to split a piece of text on a token, and then select
starts_with	tell whether or a not a string is prefixed with another string
state_boundary	returns the boundary of the US state
title_case	Make string title case with the exception of small words as defined by NYT Style Guide:
to_boolean	cast a value to a true or false
to_checkbox	No documentation is available.
to_fixed_timestamp	Turn a text value into a datetime with a fixed timezone.
to_floating_timestamp	Turn a text value into a floating datetime. “Floating” means the timezone
to_json	cast a text value to json
to_line	parse a WKT (text) representation of a line into a line value
to_location	This function has been deprecated. Please use the to_point function instead.
to_multiline	convert a line into a multiline
to_multipoint	convert a point into a multipoint
to_multipolygon	convert a polygon into a multipolygon
to_number	cast a value to a number
to_point	parse a WKT (text) representation of a point into a point value
to_polygon	parse a WKT (text) representation of a polygon into a polygon value
to_text	No documentation is available.
to_url	No documentation is available.
trim	trim characters off the start and end of a string
trim_leading	trim characters off the start of a string
trim_trailing	trim characters off the end of a string
upper	uppercase a string
uri_parse	Parse a URI.
url_decode	URL Decode a value
url_description	Extract the description part of a link.
url_encode	URL Encode a value.
url_url	Extract the url part of a link.
validate_geometry	Test that the geometry is valid.
xml_pluck	Pluck a value out of an XML string using XPath. The returned value will be a string.



Output Formats

The Socrata Open Data API supports a number of different response formats that can be specified either via response type extensions on the API endpoint or HTTP Accept headers.

Format	Extension	Mime Type	Availability »
CSV	csv	text/csv; charset=utf-8	2.0, 2.1, and 3.0
GeoJSON	geojson	application/vnd.geo+json;charset=utf-8	2.1 and 3.0
JSON	json	application/json;charset=utf-8	2.0, 2.1, and 3.0
RDF-XML	rdf	application/rdf+xml; charset=utf-8	2.0
XML	xml	text/xml; charset=utf-8	2.0 and 3.0
Neither type is better than the other - simply select the one that works best for your framework and application.

Extensions
The simplest way to specify the response format is by appending a response type extension to the URL. This allows you to set the response format without requiring the ability to set headers in your HTTP client.

Simply add the extension to the endpoint. For example, if your resource endpoint is /resource/644b-gaut, and you wanted to get CSV output, your path would be /resource/644b-gaut.csv.

HTTP Accept Headers
HTTP Accept headers allow applications to automatically negotiate content types with a web service. With SODA, this also means you can request content types using Accept headers without needing to provide a response type extension.

Simply send an Accept header along with the desired mimetype for the desired response type. For example, to request JSON, you’d use a header of Accept: application/json.

The SODA API response will also include a Content-type header to specify the format of the data that it is returning.


Datatypes

There are many core datatypes in SODA. What datatypes you may find depends on the version of your API endpoint:

Datatype	Availability »
Checkbox	2.0, 2.1, and 3.0
Fixed Timestamp	2.0, 2.1, and 3.0
Floating Timestamp	2.0 and 2.1
Line	2.1 and 3.0
Location	2.0, 2.1, and 3.0
MultiLine	2.1 and 3.0
MultiPoint	2.1 and 3.0
MultiPolygon	2.1 and 3.0
Number	2.0, 2.1, and 3.0
Point	2.1 and 3.0
Polygon	2.1 and 3.0
Text	2.0, 2.1, and 3.0
URL	2.0, 2.1, and 3.0


Other APIs
Dataset Management
Approvals
Curated Region Jobs
Curated Regions
Metadata
Publishing
Search and Discovery
Discovery
Team Search
User Search
Export and Integration
OData V2
ODN
Authentication
API Keys
Permissions